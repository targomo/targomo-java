image: $CI_REGISTRY/docker/general-image/service/psql9.6:0.0.10

# Include Global Configurations
include:
  - project: 'api-server/gitlab-ci-scripts'
    ref: v1.7
    file: '.global-configuration.yml'

stages:
  - build
  - test
  - deploy

build:
   stage: build
   script:
     - mvn --settings settings.xml clean compile
   only:
     - /^feature.*$/
     - develop

sonarqube:
   stage: test
   script:
     - mvn --settings /.ci/settings.xml verify sonar:sonar
      -Dsonar.host.url=$SONARQUBE_URL
      -Dsonar.login=$SONARQUBE_TOKEN
      -Dsonar.branch.name=$CI_COMMIT_REF_NAME
      -Dsonar.branch.target=develop
     - cat target/site/jacoco-ut/index.html
   only:
     - /^feature.*$/
     - develop

deploy_maven:
  stage: deploy
  script:
    - mvn -DperformRelease=true deploy
  artifacts:
    name: "${CI_JOB_NAME}_${CI_COMMIT_REF_NAME}"
    paths:
      - target/*.jar
  when: manual
  only:
    - master

deploy_nexus:
  stage: deploy
  script:
    - mvn -Dmaven.test.skip=true deploy
  artifacts:
    name: "${CI_JOB_NAME}_${CI_COMMIT_REF_NAME}"
    paths:
      - target/*.jar
  when: manual
  only:
    - /^feature.*$/
    - /^release.*$/
    - develop

# ----------------------------------------------------------------------------------------------------

.auto_devops: &auto_devops |
  # Auto DevOps variables and functions
  [[ "$TRACE" ]] && set -x
  auto_database_url=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${CI_ENVIRONMENT_SLUG}-postgres:5432/${POSTGRES_DB}
  export DATABASE_URL=${DATABASE_URL-$auto_database_url}
  export CI_APPLICATION_REPOSITORY=$CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG
  export CI_APPLICATION_TAG=$CI_COMMIT_SHA
  export CI_CONTAINER_NAME=ci_job_build_${CI_JOB_ID}
  export TILLER_NAMESPACE=$KUBE_NAMESPACE
  export SP_VERSION=$(echo "$CI_SERVER_VERSION" | sed 's/^\([0-9]*\)\.\([0-9]*\).*/\1-\2-stable/')


  function build() {
    if [[ -n "$CI_REGISTRY_USER" ]]; then
      echo "Logging to GitLab Container Registry with CI credentials..."
      docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
      echo ""
    fi

    if [[ -f Dockerfile ]]; then
      echo "Building Dockerfile-based application..."

      # Record versions of used config repositories
      git clone "$BASE_URL/api-server/r360-config.git" targomo-config
      (echo -n "targomo-config ";  git -C targomo-config  describe --long --tags 2>/dev/null || git -C targomo-config rev-parse --short HEAD) >> java-server/src/main/resources/version.txt
      mkdir -p java-server/src/main/resources/configs
      cp targomo-config/log4j/log4j.properties.default               java-server/src/main/resources/log4j.properties
      cp targomo-config/hibernate/hibernate.cfg.xml.kubernetes       java-server/src/main/resources/hibernate.cfg.xml
      cp targomo-config/json/server-config.json                      java-server/src/main/resources/server-config.json
      cp targomo-config/json/endpoints/*.*                           java-server/src/main/resources/configs/
      cp targomo-config/json/endpoints/server-config.kubernetes.json java-server/src/main/resources/server-config.override.json
      cat java-server/src/main/resources/server-config.override.json
      # batch mode hides the download output
      # https://stackoverflow.com/questions/21638697/disable-maven-download-progress-indication
      mvn install --batch-mode --settings settings.xml -pl java-server -am -DskipTests
      docker build -t "$CI_APPLICATION_REPOSITORY:$CI_APPLICATION_TAG" .

    else
      echo "Building Heroku-based application using gliderlabs/herokuish docker image..."
      docker run -i -e BUILDPACK_URL --name="$CI_CONTAINER_NAME" -v "$(pwd):/tmp/app:ro" gliderlabs/herokuish /bin/herokuish buildpack build
      docker commit "$CI_CONTAINER_NAME" "$CI_APPLICATION_REPOSITORY:$CI_APPLICATION_TAG"
      docker rm "$CI_CONTAINER_NAME" >/dev/null
      echo ""

      echo "Configuring $CI_APPLICATION_REPOSITORY:$CI_APPLICATION_TAG docker image..."
      docker create --expose 5000 --env PORT=5000 --name="$CI_CONTAINER_NAME" "$CI_APPLICATION_REPOSITORY:$CI_APPLICATION_TAG" /bin/herokuish procfile start web
      docker commit "$CI_CONTAINER_NAME" "$CI_APPLICATION_REPOSITORY:$CI_APPLICATION_TAG"
      docker rm "$CI_CONTAINER_NAME" >/dev/null
      echo ""
    fi

    echo "Pushing to GitLab Container Registry..."
    docker push "$CI_APPLICATION_REPOSITORY:$CI_APPLICATION_TAG"
    echo ""
  }

  function check_kube_domain() {
    if [ -z ${AUTO_DEVOPS_DOMAIN+x} ]; then
      echo "In order to deploy or use Review Apps, AUTO_DEVOPS_DOMAIN variable must be set"
      echo "You can do it in Auto DevOps project settings or defining a variable at group or project level"
      echo "You can also manually add it in .gitlab-ci.yml1"
      false
    else
      true
    fi
  }

  function install_dependencies() {
    apk add -U openssl curl tar gzip bash ca-certificates git
    wget -q -O /etc/apk/keys/sgerrand.rsa.pub https://alpine-pkgs.sgerrand.com/sgerrand.rsa.pub
    wget https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.28-r0/glibc-2.28-r0.apk
    apk add glibc-2.28-r0.apk
    rm glibc-2.28-r0.apk

    curl "https://kubernetes-helm.storage.googleapis.com/helm-v${HELM_VERSION}-linux-amd64.tar.gz" | tar zx
    mv linux-amd64/helm /usr/bin/
    mv linux-amd64/tiller /usr/bin/
    helm version --client
    tiller -version

    curl -L -o /usr/bin/kubectl "https://storage.googleapis.com/kubernetes-release/release/v${KUBERNETES_VERSION}/bin/linux/amd64/kubectl"
    chmod +x /usr/bin/kubectl
    kubectl version --client
  }

  function download_chart() {

    BASE_URL=$(echo $CI_REPOSITORY_URL | sed "s,\/*$CI_PROJECT_PATH.*,,")
    git clone "$BASE_URL/targomo/external/gitlab/auto-deploy-helm-chart.git" chart

    rm chart/templates/ingress.template.ssl.yaml
    mv chart/templates/deployment.template.yaml chart/templates/deployment.yaml
    mv chart/templates/ingress.template.yaml chart/templates/ingress.yaml
    sed -i "s/SECRET_NAME_NEEDLE/$KUBE_NAMESPACE-letsencrypt-cert/g" chart/templates/ingress.yaml

    helm init --client-only
    helm dependency update chart/
    helm dependency build chart/
  }

  function ensure_namespace() {
    kubectl describe namespace "$KUBE_NAMESPACE" || kubectl create namespace "$KUBE_NAMESPACE"
  }

  function install_tiller() {
    echo "Checking Tiller..."

    export HELM_HOST="localhost:44134"
    tiller -listen ${HELM_HOST} -alsologtostderr > /dev/null 2>&1 &
    echo "Tiller is listening on ${HELM_HOST}"

    if ! helm version --debug; then
      echo "Failed to init Tiller."
      return 1
    fi
    echo ""
  }

  function create_secret() {
    echo "Create secret..."
    if [[ "$CI_PROJECT_VISIBILITY" == "public" ]]; then
      return
    fi

    kubectl create secret -n "$KUBE_NAMESPACE" \
      docker-registry gitlab-registry \
      --docker-server="$CI_REGISTRY" \
      --docker-username="${CI_DEPLOY_USER:-$CI_REGISTRY_USER}" \
      --docker-password="${CI_DEPLOY_PASSWORD:-$CI_REGISTRY_PASSWORD}" \
      --docker-email="$GITLAB_USER_EMAIL" \
      -o yaml --dry-run | kubectl replace -n "$KUBE_NAMESPACE" --force -f -
  }

  function deploy() {

    echo "Installing CI_APPLICATION_REPOSITORY: $CI_APPLICATION_REPOSITORY"
    echo "           CI_APPLICATION_TAG:        $CI_APPLICATION_TAG"
    echo "           KUBE_NAMESPACE:            $KUBE_NAMESPACE"
    echo "           CI_ENVIRONMENT_SLUG:       $CI_ENVIRONMENT_SLUG"
    echo "           CI_ENVIRONMENT_URL:        $CI_ENVIRONMENT_URL"

    helm upgrade --install \
      --wait \
      --force \
      --debug \
      --set service.enabled="true" \
      --set service.internalPort="444" \
      --set releaseOverride="$CI_ENVIRONMENT_SLUG" \
      --set image.repository="$CI_APPLICATION_REPOSITORY" \
      --set image.tag="$CI_APPLICATION_TAG" \
      --set image.pullPolicy=IfNotPresent \
      --set image.secrets[0].name="gitlab-registry" \
      --set service.livenessProbe.initialDelaySeconds="200" \
      --set service.livenessProbe.timeoutSeconds="10" \
      --set service.livenessProbe.periodSeconds="10" \
      --set service.livenessProbe.successThreshold="1" \
      --set service.livenessProbe.failureThreshold="5" \
      --set service.readinessProbe.initialDelaySeconds="200" \
      --set service.readinessProbe.timeoutSeconds="10" \
      --set service.readinessProbe.periodSeconds="10" \
      --set service.readinessProbe.successThreshold="1" \
      --set service.readinessProbe.failureThreshold="5" \
      --set application.track="stable" \
      --set application.database_url="$DATABASE_URL" \
      --set service.url="$CI_ENVIRONMENT_URL" \
      --set replicaCount="1" \
      --set postgresql.enabled="false" \
      --namespace="$KUBE_NAMESPACE" \
      --version="$CI_PIPELINE_ID-$CI_JOB_ID" \
      "$CI_ENVIRONMENT_SLUG" \
      chart/

    while [[ "$(curl -s -o /dev/null -w ''%{http_code}'' ${CI_ENVIRONMENT_URL/http/https})" != "200" ]]; do
      echo "Review App not up. Retrying."
      sleep 5
    done
    echo "Review App up and reachable at: ${CI_ENVIRONMENT_URL/http/https}"
  }

  function persist_environment_url() {
      echo $CI_ENVIRONMENT_URL > environment_url.txt
  }

  function delete() {
    track="${1-stable}"
    name="$CI_ENVIRONMENT_SLUG"

    if [[ "$track" != "stable" ]]; then
      name="$name-$track"
    fi

    if [[ -n "$(helm ls -q "^$name$")" ]]; then
      helm delete "$name"
    fi
  }


before_script:
  - *auto_devops
  - docker_login
